y---
title: "Steps"
output: html_notebook
---
#This step is already having cleaned data

```{r}
library(foreign)
edat<- read.csv("~/Desktop/edsproject/data_cleaned.csv")
dat<- read.dta("~/Desktop/edsproject/china_univ_by_municipality.dta")

#merge two data frames by year and cityid
total<- merge(edat, dat, by=c("cityid", "year"))

#create some group variables
#citycategory<-c("")
```

Briefly look at the data
```{r}
dim(edat)
dim(dat)

#explore panel data
library(gplots)
plotmeans(ncampus~year, main="Number of campuses in China 1985-2011", n.label= FALSE, data=total)
#plotmeans(ncampus~provid|year==2010, main="Number of campuses in China 1985-2011", n.label= FALSE, data=dat)
```

Now we want to take a look at the 2010 year of data only.
```{r}
#not sure about how to analyze the features of panel data, so I only select the year of 2010 and see what could be the possible cluster.

#create subset

only2010<- total[which(total$year==2010),]



#drop unnecessary variables
only2010<- only2010[c(-3,-4,-5,-8,-9,-13,-14,-15,-16,-30,-31,-32,-33,-34,-35,-36,-37,-38,-39,-40,-41,-43,-44,-45)]
dim(only2010)

#Sort the variables order
only2010<-only2010[,c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39)]
only2010<-only2010[,c(1,2,3,4,5,6,8,10,12,14,16,19,7,9,11,13,15,17,18,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39)]


plotmeans(ncampus~provid.x,bars=FALSE, main="Number of campuses in China 2010, by province", data=only2010)

aggregate(ncampus ~ citycat, data=only2010, mean)
 
aggregate(ncampus ~ provid.x, data=only2010, mean)


```

#Primary analysis of demographic features

```{r}
par(mfrow=c(1,2))
plot(density(only2011$poptota))
plot(density(only2011$poptotc))
#obviously the poptota has more density.

#plot(density(only2011$gdpcapa))
#plot(density(only2011$gdpcapc))
#this cannot be run because of missing values


#look at the population spread (bivariate relationship), not obvious founding
pairs(only2011[,11:12],pch=16)

#see if we can get anywhere with additional exploration of principal component
pc<- pairs(princomp(only2011[,11:12])$scores)
#hard to see any founding

#3D?
install.packages("rgl")
require(rgl)
library(rgl)
##having problems installing this package





```

Now we can look at the school features

```{r}

#None of these make sense here
require(cluster)
require(foreign)
require(lattice)
require(gtools)

hcl.single<- hclust(dist(scale(only2010[,6:12])),meth="single")
plot(hcl.single)

hcl.complete <- hclust(dist(scale(only2010[,6:12])), meth="complete")
plot(hcl.complete)

hcl.ward<-  hclust(dist(scale(only2010[,6:12])), meth="ward")
plot(hcl.ward) 

#try kmeans
#return to error
km.2010.3<- kmeans(only2010[,6:12],3,nstart = 100)
```

Now we want to get the maximal agreement

```{r}
require(gtools)
optLabel <- function(src,trg) {
    #input two sets of labels, find permuation that maximizes agreement
    #to be complete search, and handle simpler diag eval, trg must have larger # of labels
    n1 <- length(unique(src))
    n2 <- length(unique(trg))
    tbl <- xtabs(~src+trg)
    best.match <- sum(diag(tbl)) #still works for a non-square matrix.
    best.perm <- 1:n2
    allPerms <- permutations(n2,n2)
    for (i in 1:dim(allPerms)[1]) {
        cur.match <- sum(diag(tbl[,allPerms[i,]]))
        if (cur.match>best.match) {
            best.match <- cur.match
            best.perm <- allPerms[i,]
        }
    }
    list(best.match=best.match,best.perm=best.perm,best.tbl=tbl[,best.perm])
}

c.crit <- function(km.obj) {
    #based on k-means, for convenience due to amt of addl info in the km result object.
    #cd be generalized.
    sizes <- km.obj$size
    n <- sum(sizes)
    g <- length(sizes)
    msW<-sum(km.obj$withinss)/(n-g)
    overall.mean <- apply(km.obj$centers*km.obj$size,2,sum)/sum(km.obj$size)
    msB<-sum(km.obj$size*(t(t(km.obj$centers)-overall.mean))^2)/(g-1)
    list(msB=msB,msW=msW,C.g=msB/msW)
}


numGroupSearch <- function(features,rng=c(2,10),wilks=T,nstart=1) {

    mn <- rng[1]
    mx <- rng[2]
    m.list <- km.list <- vector("list",length=mx-mn+1)
    cFn <- p.rsq <- rep(NA,mx-mn+1)
    i <- 0
    for (k in mn:mx) {
        i <- i+1
        km.list[[i]] <- kmeans(features,k,nstart=nstart)
        U <- as.matrix(features)
        m.list[[i]] <- manova(U~factor(km.list[[i]]$cluster))
        if (wilks) { #avoids some degenerate cases
            p.rsq[i] <- 1-summary(m.list[[i]],test="Wilks")$stats[1,2]
        }
        cFn[i] <- c.crit(km.list[[i]])$C.g
    }
    return(list(km.list=km.list,m.list=m.list,p.rsq=p.rsq,cFn=cFn))
}
```





